### Implementation of Self-Consistent Transport and Time-Interlaced Backward Induction in Heterogeneous Agent Models


This repository contains a collection of programs written in Julia for computing macroeconomic equlibrium in models of Krusell-Smith or Aiyagari-Bewley-Huggett type. The meaning and the purpose of these programs is exaplained in the paper <i> Self-Consistent Transport in Heterogeneous Agent Models</i> &nbsp;[STHAM]&nbsp; in: Statistics of Random Processes and Optimal Control, Prof. A. N. Shiryaev Festschrift. Springer Nature (2025), which this repository supplements.

The code in &nbsp;&#8902;-RMT-&#8902;.jl&nbsp; implements accurately the method described in Ch 18 of the book &ldquo;<i>Recursive Macroeconomic Theory</i>&rdquo;  &nbsp;[RMT]&nbsp; by L. Ljungvist and T. Sargent for calculating the equilibrium in Huggett's benchmark pure-exchange economy with no shared risk. The model parameters are borrowed from &nbsp;[RMT]&nbsp;. The purpose of this code is to demonstrate that, contrary to the common belief (see &nbsp;[RMT]&nbsp;) a central problem in macroeconomics has been without an adequate solution since it was first formulated more than 30 years ago, save for some special case. More details about this finding are provided in &nbsp;[SATEA, Sec. 1]&nbsp;.

The programs &nbsp;&#8902;-SATEA-sec3&#8902;.jl&nbsp; implement the alternative algorithm described in &nbsp;[STHAM, Sec. 3]&nbsp; and produce a numerically verifiable equilibrium for the pure-echnage economy with no aggregate risk described in &nbsp;[RMT]&nbsp; and covered by &nbsp;&#8902;-RMT-&#8902;.jl&nbsp;. The need for developing this alternative algorithm is explained in the paper &nbsp;[SATEA, Sec. 1]&nbsp;

The programs &nbsp;&#8902;-SATEA-sec4&#8902;.jl&nbsp; implement the algorithm described in Sec. 4 of &nbsp;[STHAM]&nbsp; and produce an approxiamte equilibrium for the benchmark economy with aggregate risk and production described in the paper &nbsp;&ldquo;<i>Income and wealth heterogeneity in the macroeconomy</i>&rdquo; &nbsp; by P. Krusell and A. Smith, Journal of Political Economy 106 (1998) pp. 867-896. The reason for for developing this alternative algorithm is explained in the paper &nbsp;[SHAM, Sec. 1, Sec. 4]&nbsp;.

The Julia code in &nbsp;functions-&#8902;.jl&nbsp; contains the actual procedures. The Julia code in &nbsp;ini-setup-&#8902;.jl&nbsp; defines the parameters. The output associated with a specific model is generated by executing the respctive file &nbsp;run-&#8902;.jl&nbsp;, which reads the necessary &nbsp;ini-setup-&#8902;.jl&nbsp; and &nbsp;functions-&#8902;.jl&nbsp; files and stores the output in a unique binary (not human redable) file &nbsp;output-&#8902;.jls&nbsp; (available this repository). The files &nbsp;post-run-&#8902;.jls&nbsp; read the data stored in the respective &#8902;.jls and allow one to play with the output and generate the illustrations in &nbsp;[SHAM]&nbsp; without the need to execute &nbsp;run-&#8902;.jl&nbsp;. The illustrations described in &nbsp;[STHAM]&nbsp; (including all plots) and some additional ones can be generated by the code stored in &nbsp;post-run-&#8902;.jl&nbsp;, which is meant to be executed block-by-block in a notebook style (see the example with the jupyter notebook post-run-RMT-ch18.ipynb, which replicates the most essential part of post-run-RMT-ch18.jl). All plots in the paper &nbsp;[STHAM]&nbsp; are generated by Gnuplot.jl with the code in post-run-&#8902;.jl.

All reported output is produced with generic Linux-on-x86 binaries (glibc) Version 1.10.4 (2024-06-04) retreived from https://julialang.org/downloads/
